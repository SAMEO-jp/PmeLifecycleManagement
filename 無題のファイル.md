素晴らしい質問です！Drizzle + Supabase環境でAPI機能を設計する際の思考プロセスを、SE的な視点で説明しますね 🏗️

## 設計思考プロセス 🧠

```
┌─────────────────────────────────────────────────────────┐
│ STEP 1: 要件分析と境界定義                                │
└──────────────┬──────────────────────────────────────────┘
               │
┌──────────────▼──────────────────────────────────────────┐
│ STEP 2: データモデリング（DB設計）                         │
└──────────────┬──────────────────────────────────────────┘
               │
┌──────────────▼──────────────────────────────────────────┐
│ STEP 3: レイヤー設計（責任分離）                           │
└──────────────┬──────────────────────────────────────────┘
               │
┌──────────────▼──────────────────────────────────────────┐
│ STEP 4: API設計（エンドポイント定義）                      │
└──────────────┬──────────────────────────────────────────┘
               │
┌──────────────▼──────────────────────────────────────────┐
│ STEP 5: エラーハンドリング戦略                             │
└──────────────┬──────────────────────────────────────────┘
               │
┌──────────────▼──────────────────────────────────────────┐
│ STEP 6: セキュリティ・認証設計                             │
└──────────────┬──────────────────────────────────────────┘
               │
┌──────────────▼──────────────────────────────────────────┐
│ STEP 7: 実装順序の決定                                    │
└─────────────────────────────────────────────────────────┘
```

---

## STEP 1: 要件分析と境界定義 📋

### 思考プロセス

```
機能要求 → ユースケース抽出 → 境界決定

例：「プロジェクトメンバー管理機能」の場合

【ユースケース】
├─ UC-01: メンバー招待
├─ UC-02: メンバー一覧表示
├─ UC-03: メンバー削除
├─ UC-04: 権限変更
└─ UC-05: 招待受諾/拒否

【境界定義】
├─ この機能が扱う範囲
│   ├─ プロジェクトへのメンバー追加/削除
│   ├─ メンバーの権限管理
│   └─ 招待リンク生成
│
└─ この機能が扱わない範囲
    ├─ ユーザー登録（別機能）
    ├─ プロジェクト作成（別機能）
    └─ タスク割り当て（別機能）
```

### アーキテクチャ判断

```
【質問1】この機能は同期処理？非同期処理？
├─ 同期: 即座にレスポンスが必要
└─ 非同期: バックグラウンド処理が必要
    └─ → Queue/Job システムが必要

【質問2】リアルタイム性が必要？
├─ Yes → Supabase Realtime使用
└─ No → 通常のポーリングでOK

【質問3】トランザクション境界は？
└─ 複数テーブルの整合性を保証する必要がある範囲
```

---

## STEP 2: データモデリング 🗄️

### Drizzle スキーマ設計思考

```
【ER図設計】

┌──────────────┐         ┌──────────────────┐
│   projects   │1      n│ project_members  │
│──────────────│─────────│──────────────────│
│ id           │         │ id               │
│ name         │         │ project_id  (FK) │
│ created_at   │         │ user_id     (FK) │
└──────────────┘         │ role             │
                         │ invited_at       │
                         │ joined_at        │
                         │ status           │
      │                  └──────────────────┘
      │                           │
      │1                          │n
      │                           │
      │n                          │1
      │                           │
┌─────▼──────┐         ┌─────────▼────┐
│   tasks    │         │    users     │
│────────────│         │──────────────│
│ id         │         │ id           │
│ project_id │         │ email        │
│ name       │         │ name         │
└────────────┘         └──────────────┘
```

### スキーマファイル構成

```
src/db/
├── schema/
│   ├── projects.schema.ts          # プロジェクトテーブル定義
│   ├── projectMembers.schema.ts    # メンバー関連テーブル
│   ├── users.schema.ts              # ユーザーテーブル
│   └── index.ts                     # スキーマ統合エクスポート
│
├── types/
│   └── schema.types.ts              # Drizzle型定義（自動生成）
│
└── migrations/
    └── 0001_add_project_members.sql # マイグレーションファイル
```

### 設計判断ポイント

```
【インデックス戦略】
├─ 頻繁に検索するカラム → インデックス作成
│   └─ project_members.project_id
│   └─ project_members.user_id
│
├─ 複合インデックス
│   └─ (project_id, user_id) → メンバー重複チェック
│
└─ 一意制約
    └─ (project_id, user_id) UNIQUE → 同じユーザーの重複登録防止

【カラム設計】
├─ status: enum('pending', 'active', 'rejected')
│   └─ 招待状態を明示的に管理
│
├─ role: enum('owner', 'admin', 'member', 'viewer')
│   └─ 権限レベルを明確に定義
│
└─ deleted_at: timestamp nullable
    └─ 論理削除（物理削除しない設計）
```

---

## STEP 3: レイヤー設計（責任分離） 🏛️

### アーキテクチャパターン

```
┌─────────────────────────────────────────────────────────┐
│                     API Layer (Next.js)                  │
│  app/api/projects/[id]/members/                          │
│    ├── route.ts              ← GET/POST エンドポイント   │
│    └── [memberId]/route.ts  ← PUT/DELETE エンドポイント  │
└────────────────┬────────────────────────────────────────┘
                 │
┌────────────────▼────────────────────────────────────────┐
│                 Controller Layer (薄い層)                │
│  lib/controllers/projectMemberController.ts              │
│    ├── handleGetMembers()      ← リクエスト検証          │
│    ├── handleInviteMember()    ← レスポンス整形          │
│    └── handleRemoveMember()    ← エラーハンドリング      │
└────────────────┬────────────────────────────────────────┘
                 │
┌────────────────▼────────────────────────────────────────┐
│                  Service Layer (厚い層)                  │
│  lib/services/projectMemberService.ts                    │
│    ├── inviteMember()          ← ビジネスロジック        │
│    ├── getProjectMembers()     ← トランザクション制御    │
│    ├── removeMember()          ← 権限チェック            │
│    └── updateMemberRole()      ← 通知送信                │
└────────────────┬────────────────────────────────────────┘
                 │
┌────────────────▼────────────────────────────────────────┐
│              Repository Layer (データアクセス)            │
│  lib/repositories/projectMemberRepository.ts             │
│    ├── findMembersByProjectId()  ← Drizzleクエリ        │
│    ├── createMember()             ← CRUD操作             │
│    ├── updateMember()             ← データ変換           │
│    └── deleteMember()             ← トランザクション     │
└────────────────┬────────────────────────────────────────┘
                 │
┌────────────────▼────────────────────────────────────────┐
│                   Database (Supabase)                    │
│  ├── Drizzle ORM                                         │
│  ├── PostgreSQL                                          │
│  └── RLS (Row Level Security)                            │
└─────────────────────────────────────────────────────────┘

【横断的関心事】
├── lib/auth/                    ← 認証・認可
├── lib/validation/              ← バリデーション
├── lib/errors/                  ← エラー定義
├── lib/notifications/           ← 通知システム
└── lib/logging/                 ← ロギング
```

### 各層の責務定義

```
【API Layer】
役割: HTTPリクエスト/レスポンスの入出力口
責務:
  ├─ ルーティング
  ├─ HTTPステータスコード返却
  ├─ CORS設定
  └─ レート制限
やらないこと:
  └─ ビジネスロジック（Controllerに委譲）

【Controller Layer】
役割: リクエスト処理のオーケストレーション
責務:
  ├─ リクエストデータの検証（zodスキーマ）
  ├─ Service層の呼び出し
  ├─ レスポンスの整形
  └─ エラーハンドリング（try-catch）
やらないこと:
  └─ データベース直接操作（Repositoryに委譲）

【Service Layer】
役割: ビジネスロジックの実装
責務:
  ├─ トランザクション制御
  ├─ 複数Repositoryの協調
  ├─ 権限チェック
  ├─ 外部API呼び出し（通知など）
  └─ ドメインルール実装
やらないこと:
  └─ SQL直接記述（Repositoryに委譲）

【Repository Layer】
役割: データ永続化の抽象化
責務:
  ├─ Drizzleクエリ構築
  ├─ データマッピング（DB ↔ Domain）
  ├─ キャッシュ制御
  └─ トランザクション実行
やらないこと:
  └─ ビジネスロジック（Serviceに委譲）
```

---

## STEP 4: API設計（エンドポイント定義） 🔌

### RESTful設計思考

```
【リソース設計】
/api/projects/{projectId}/members

【エンドポイント一覧】

┌─────────────────────────────────────────────────────────┐
│ GET  /api/projects/{projectId}/members                   │
│  ├─ 目的: メンバー一覧取得                                │
│  ├─ 認証: 必須（プロジェクトメンバーのみ）                │
│  ├─ クエリパラメータ:                                     │
│  │   ├─ ?status=active|pending                           │
│  │   ├─ ?role=owner|admin|member                         │
│  │   └─ ?page=1&limit=20                                 │
│  └─ レスポンス: { members: [...], total, page }          │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│ POST /api/projects/{projectId}/members                   │
│  ├─ 目的: メンバー招待                                    │
│  ├─ 認証: 必須（owner/adminのみ）                        │
│  ├─ ボディ: { email, role }                             │
│  ├─ 処理:                                                │
│  │   ├─ ユーザー存在チェック                             │
│  │   ├─ 重複チェック                                     │
│  │   ├─ 招待レコード作成                                 │
│  │   └─ 招待メール送信                                   │
│  └─ レスポンス: { member, inviteToken }                 │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│ PUT  /api/projects/{projectId}/members/{memberId}        │
│  ├─ 目的: メンバー情報更新（ロール変更）                  │
│  ├─ 認証: 必須（owner/adminのみ）                        │
│  ├─ ボディ: { role }                                     │
│  └─ レスポンス: { member }                              │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│ DELETE /api/projects/{projectId}/members/{memberId}      │
│  ├─ 目的: メンバー削除                                    │
│  ├─ 認証: 必須（owner/admin または本人）                 │
│  ├─ 処理:                                                │
│  │   ├─ 権限チェック                                     │
│  │   ├─ 論理削除実行                                     │
│  │   └─ 関連タスクの再割り当て                           │
│  └─ レスポンス: { success: true }                       │
└─────────────────────────────────────────────────────────┘
```

### リクエスト/レスポンス設計

```
【標準レスポンス形式】

成功時:
{
  "success": true,
  "data": { ... },
  "meta": {
    "timestamp": "2025-01-01T00:00:00Z",
    "requestId": "uuid"
  }
}

エラー時:
{
  "success": false,
  "error": {
    "code": "MEMBER_ALREADY_EXISTS",
    "message": "このユーザーは既にメンバーです",
    "details": { ... }
  },
  "meta": {
    "timestamp": "2025-01-01T00:00:00Z",
    "requestId": "uuid"
  }
}

【バリデーションスキーマ】
lib/validation/projectMember.schema.ts
  ├─ inviteMemberSchema
  ├─ updateMemberRoleSchema
  └─ getMembersQuerySchema
```

---

## STEP 5: エラーハンドリング戦略 ⚠️

### エラー分類と処理

```
┌─────────────────────────────────────────────────────────┐
│                   エラー階層構造                          │
└─────────────────────────────────────────────────────────┘

AppError (基底クラス)
  ├── ValidationError (400)
  │     ├── InvalidEmailError
  │     └── InvalidRoleError
  │
  ├── AuthenticationError (401)
  │     ├── TokenExpiredError
  │     └── InvalidTokenError
  │
  ├── AuthorizationError (403)
  │     ├── InsufficientPermissionError
  │     └── ProjectAccessDeniedError
  │
  ├── NotFoundError (404)
  │     ├── ProjectNotFoundError
  │     ├── MemberNotFoundError
  │     └── UserNotFoundError
  │
  ├── ConflictError (409)
  │     ├── MemberAlreadyExistsError
  │     └── DuplicateInviteError
  │
  └── InternalServerError (500)
        ├── DatabaseError
        └── ExternalServiceError
```

### エラーハンドリングフロー

```
API層
  ↓ try
Controller層
  ↓ try
Service層
  ↓ throw ValidationError
Controller層
  ↓ catch → エラー変換
API層
  ↓ レスポンス整形
クライアント
  ↓ エラー表示

【実装構造】
lib/errors/
  ├── AppError.ts              ← 基底エラークラス
  ├── ValidationError.ts       ← バリデーションエラー
  ├── AuthorizationError.ts    ← 認可エラー
  └── errorHandler.ts          ← グローバルエラーハンドラー
```

---

## STEP 6: セキュリティ・認証設計 🔒

### 認証フロー

```
┌─────────────────────────────────────────────────────────┐
│                    認証レイヤー                           │
└─────────────────────────────────────────────────────────┘

クライアント
  │
  ├─ Authorization: Bearer {token}
  │
  ↓
API Middleware (Next.js)
  │
  ├─ トークン検証
  ├─ Supabase Auth確認
  └─ ユーザー情報取得
  │
  ↓
権限チェック (Service層)
  │
  ├─ プロジェクトメンバーか？
  ├─ 必要なロールを持っているか？
  └─ リソースオーナーか？
  │
  ↓
RLS (Supabase)
  │
  └─ データベースレベルでの権限チェック
```

### RLS (Row Level Security) 設計

```
【RLSポリシー例】

-- メンバー一覧の閲覧権限
CREATE POLICY "project_members_select"
ON project_members FOR SELECT
USING (
  EXISTS (
    SELECT 1 FROM project_members pm
    WHERE pm.project_id = project_members.project_id
      AND pm.user_id = auth.uid()
      AND pm.status = 'active'
  )
);

-- メンバー追加権限（owner/adminのみ）
CREATE POLICY "project_members_insert"
ON project_members FOR INSERT
WITH CHECK (
  EXISTS (
    SELECT 1 FROM project_members pm
    WHERE pm.project_id = project_members.project_id
      AND pm.user_id = auth.uid()
      AND pm.role IN ('owner', 'admin')
  )
);
```

---

## STEP 7: 実装順序の決定 📝

### ボトムアップ実装戦略

```
Phase 1: 基盤構築
  ├─ 1-1. Drizzleスキーマ定義
  ├─ 1-2. マイグレーション実行
  ├─ 1-3. 型定義生成
  └─ 1-4. Repository層実装

Phase 2: ビジネスロジック
  ├─ 2-1. Service層実装
  ├─ 2-2. バリデーションスキーマ
  ├─ 2-3. エラークラス定義
  └─ 2-4. ユニットテスト作成

Phase 3: API構築
  ├─ 3-1. Controller層実装
  ├─ 3-2. APIルート実装
  ├─ 3-3. ミドルウェア実装
  └─ 3-4. 統合テスト作成

Phase 4: セキュリティ
  ├─ 4-1. RLSポリシー作成
  ├─ 4-2. 認証ミドルウェア
  └─ 4-3. 権限チェック実装

Phase 5: 最適化
  ├─ 5-1. クエリ最適化
  ├─ 5-2. キャッシュ導入
  └─ 5-3. パフォーマンステスト
```

### 依存関係管理

```
実装順序の原則: 依存される側から実装

Database (Drizzle Schema)
  ↑ 依存
Repository Layer
  ↑ 依存
Service Layer
  ↑ 依存
Controller Layer
  ↑ 依存
API Layer

【並行作業可能な部分】
├─ バリデーションスキーマ（独立）
├─ エラークラス（独立）
├─ 型定義（独立）
└─ テストコード（各層完成後）
```

---

## 設計判断のチェックリスト ✅

```
□ データモデルは正規化されているか？
□ トランザクション境界は明確か？
□ N+1問題は発生しないか？
□ 適切なインデックスが設定されているか？
□ 各層の責務は明確に分離されているか？
□ エラーハンドリングは網羅的か？
□ セキュリティホールはないか？
□ テスタビリティは確保されているか？
□ スケーラビリティは考慮されているか？
□ ログ・モニタリングは実装されているか？
```

この思考プロセスで、堅牢で保守性の高いAPI機能を設計できます 🎯