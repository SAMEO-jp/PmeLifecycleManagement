## データベース既存時のService層設計思考プロセス 🧠

---

## PHASE 1: ドメイン分析とサービス境界定義 🎯

```
┌──────────────────────────────────────────────────────┐
│        思考の出発点：ドメインから逆算する            │
└──────────────────────────────────────────────────────┘

既存データベース
      ↓
【STEP 1】テーブル群を機能ドメインにグルーピング
      ↓
【STEP 2】各ドメインのユースケースを抽出
      ↓
【STEP 3】ユースケースからService境界を決定
      ↓
【STEP 4】Serviceが必要とするRepositoryを特定
      ↓
【STEP 5】Repository間の依存関係を整理
```

---

## 設計思考フロー：抽象化モデル 📋

```
┌──────────────────────────────────────────────────────┐
│           既存DBの分析とグルーピング                 │
└──────────────────────────────────────────────────────┘

【既存テーブル構造の把握】
主エンティティテーブル
  ├─ EntityA_table
  ├─ EntityB_table
  └─ EntityC_table

サブエンティティ・分類テーブル
  ├─ EntityA_type_table
  └─ EntityB_category_table

関連テーブル（中間テーブル・多対多）
  ├─ EntityA_EntityB_relation
  ├─ EntityA_EntityC_relation
  └─ EntityB_EntityC_relation

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【STEP 1】機能ドメインへのグルーピング指針

グルーピング基準:
  ├─ ビジネス上の関連性
  ├─ データのライフサイクルの共通性
  ├─ トランザクション境界の一致
  └─ アクター（利用者）の共通性

Domain X: Core Entity Management
  └─ EntityA_table, EntityA_type_table,
      EntityA_EntityB_relation

Domain Y: Secondary Entity Management
  └─ EntityB_table, EntityB_category_table,
      EntityB_EntityC_relation

Domain Z: Cross-Cutting Concerns
  └─ EntityC_table

Domain W: Association Management
  └─ EntityA_EntityB_relation,
      EntityA_EntityC_relation
```

---

## STEP 2-3: ユースケース抽出とService境界決定 🎭

```
┌──────────────────────────────────────────────────────┐
│        ユースケース → Service マッピング            │
└──────────────────────────────────────────────────────┘

Domain: Core Entity Management
      │
      ├─ UC-01: エンティティ作成
      ├─ UC-02: エンティティ一覧取得
      ├─ UC-03: エンティティ更新
      ├─ UC-04: エンティティ削除
      ├─ UC-05: 関連付け追加
      ├─ UC-06: 関連付け削除
      └─ UC-07: ステータス変更
      │
      └─--> EntityManagementService
           └─--> EntityAssociationService
                 (複雑性が高い場合は分離)

Domain: Secondary Entity Management
      │
      ├─ UC-11: サブエンティティ作成
      ├─ UC-12: サブエンティティ割り当て
      ├─ UC-13: ステータス更新
      ├─ UC-14: 依存関係設定
      └─ UC-15: 進捗計算
      │
      └─--> SecondaryEntityService
           └─--> AssignmentService
                 (割り当てロジックが複雑な場合)

Domain: Cross-Cutting Entity Management
      │
      ├─ UC-21: 共通エンティティ情報取得
      ├─ UC-22: 共通エンティティ更新
      └─ UC-23: 関連情報の集約取得
      │
      └─--> CommonEntityService

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【Service分割の判断基準】

単一Service維持 ✅
  ├─ 責務が明確
  ├─ メソッド数 10以下
  └─ トランザクション境界が一貫

分割検討 ⚠️
  ├─ メソッド数 15以上
  ├─ 異なるトランザクション境界
  ├─ 異なるアクター（利用者）
  └─ 独立して進化する可能性

【分割例】
CoreEntityService (8メソッド)
  ├─ create()
  ├─ update()
  ├─ delete()
  ├─ findById()
  ├─ findAll()
  ├─ archive()
  ├─ restore()
  └─ getStatistics()

EntityAssociationService (6メソッド) <-- 分離
  ├─ addAssociation()
  ├─ removeAssociation()
  ├─ updateAssociationStatus()
  ├─ getAssociations()
  ├─ acceptAssociation()
  └─ checkAssociation()

分離理由: 関連管理は独立した複雑なドメインロジック
```

---

## STEP 4: 必要なRepository特定 🔍

```
┌──────────────────────────────────────────────────────┐
│       Service → Repository 依存関係マッピング       │
└──────────────────────────────────────────────────────┘

【思考プロセス】

1. Serviceメソッドを列挙
2. 各メソッドが触るテーブルを特定
3. テーブル単位でRepositoryを定義

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

CoreEntityService
  │
  ├─ create(data)
  │   └─ 必要: CoreEntityRepository.create()
  │
  ├─ findById(id)
  │   └─ 必要: CoreEntityRepository.findById()
  │
  └─ getWithAssociations(id)
      ├─ 必要: CoreEntityRepository.findById()
      └─ 必要: AssociationRepository
                .findByCoreEntityId()

EntityAssociationService
  │
  ├─ addAssociation(entityId, targetId, type)
  │   ├─ 必要: CoreEntityRepository.findById()
  │   ├─ 必要: TargetEntityRepository.findById()
  │   ├─ 必要: AssociationRepository
  │   │         .findByEntities()
  │   └─ 必要: AssociationRepository.create()
  │
  └─ removeAssociation(entityId, targetId)
      ├─ 必要: AssociationRepository
      │         .findByEntities()
      ├─ 必要: RelatedDataRepository
      │         .findByAssociation()
      └─ 必要: AssociationRepository.delete()

SecondaryEntityService
  │
  ├─ createEntity(parentId, data)
  │   ├─ 必要: SecondaryEntityRepository.create()
  │   ├─ 必要: RelationRepository.create()
  │   └─ 必要: EntityTypeRepository.findById()
  │
  └─ assignEntity(entityId, targetId)
      ├─ 必要: SecondaryEntityRepository.findById()
      ├─ 必要: TargetEntityRepository.findById()
      └─ 必要: AssignmentRepository.create()

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【必要なRepository一覧の導出】

1対1マッピング（テーブル = Repository）
  ├─ CoreEntityRepository
  ├─ SecondaryEntityRepository
  ├─ TargetEntityRepository
  └─ EntityTypeRepository

関連テーブル専用Repository
  ├─ AssociationRepository
  ├─ RelationRepository
  └─ AssignmentRepository

【Repository作成の原則】
├─ 1テーブル = 1Repository（基本ルール）
├─ 中間テーブルも独立したRepository
└─ ViewやJOIN結果は既存Repositoryメソッドで対応
```

---

## STEP 5: Repository設計戦略 🏗️

```
┌──────────────────────────────────────────────────────┐
│          Repository設計：2つのアプローチ             │
└──────────────────────────────────────────────────────┘

アプローチA: 基底Repository + 継承

┌─────────────────────────────────┐
│ BaseRepository<T>               │
│   ├─ findById(id)               │
│   ├─ findAll(options?)          │
│   ├─ create(data)               │
│   ├─ update(id, data)           │
│   ├─ delete(id)                 │
│   └─ count(where?)              │
└───────────┬─────────────────────┘
            │ 継承
    ┌───────┴───────┐
    │               │
EntityARepository  EntityBRepository
    │               │
    ├─ カスタム     ├─ カスタム
    │  メソッド     │  メソッド
    ├─ findByCode()
    │               ├─ findByStatus()
    └─ findActive() └─ findExpired()


アプローチB: コンポジション（推奨）

┌─────────────────────────────────┐
│ EntityRepository                │
│   ├─ 基本CRUD                   │
│   │   ├─ findById()             │
│   │   ├─ findAll()              │
│   │   ├─ create()               │
│   │   └─ update()               │
│   │                             │
│   └─ ドメイン固有クエリ          │
│       ├─ findByUniqueKey()      │
│       ├─ findByOwner()          │
│       ├─ findActive()           │
│       └─ searchByAttribute()    │
└─────────────────────────────────┘

【推奨理由】
├─ ORM（Drizzle/Prisma等）の型安全性を活かせる
├─ 各Repositoryが完全に独立
├─ テスト・モックが容易
└─ 継承の複雑性を回避
```

---

## 汎用CRUD vs カスタムメソッド設計 ⚖️

```
┌──────────────────────────────────────────────────────┐
│        生SQL時代 vs ORM時代の設計アプローチ          │
└──────────────────────────────────────────────────────┘

【生SQL/軽量ライブラリ時代】
共通パターンの重複
  └─ 汎用CRUDヘルパー必須

例:
  db.run("INSERT INTO table_a ...")
  db.run("INSERT INTO table_b ...")
  db.run("INSERT INTO table_c ...")
      ↑ 毎回似たようなSQL

解決策: 汎用CRUD関数
  ├─ insert(table, data)
  ├─ update(table, id, data)
  ├─ select(table, where)
  └─ delete(table, id)


【ORM時代（Drizzle/Prisma/TypeORM等）】
ORM提供の型安全API
  └─ 既に汎用化されている
      └─ 独自の汎用CRUD不要

例:
  orm.insert(tableA).values(data)
  orm.insert(tableB).values(data)
  orm.insert(tableC).values(data)
      ↑ 既に統一的なインターフェース

結論: ORMが提供するAPIをそのまま使用
  └─ 追加の抽象化は不要（過剰設計）

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【Repositoryメソッド設計指針】

基本CRUD（シンプルに実装）
  ├─ findById(id)
  │   └─ ORMのselect APIを直接使用
  │
  ├─ findAll(options)
  │   └─ クエリビルダーで柔軟に構築
  │
  ├─ create(data)
  │   └─ ORMのinsert APIを直接使用
  │
  └─ update(id, data)
      └─ ORMのupdate APIを直接使用

ドメイン固有クエリ（価値ある抽象化）
  ├─ findByUniqueKey(key)
  │   └─ ビジネスロジックで頻出
  │
  ├─ findActiveEntities()
  │   └─ 複雑な条件の名前付きメソッド化
  │
  └─ findWithRelations(id)
      └─ 複雑なJOINの隠蔽

【設計判断ガイドライン】

汎用CRUD層を作らない ✅
  └─ ORM APIで十分
  └─ 過剰な抽象化を避ける

ドメイン固有メソッドを作る ✅
  └─ 意図を明確に表現
  └─ 複雑性を隠蔽
  └─ 再利用性を提供
  └─ テスタビリティ向上
```

---

## Repository層の粒度設計 📐

```
┌──────────────────────────────────────────────────────┐
│          Repository粒度の判断フロー                  │
└──────────────────────────────────────────────────────┘

【質問1】このテーブルは独立したエンティティか？
  YES --> 専用Repository作成
    例: entity_table --> EntityRepository

【質問2】このテーブルは中間テーブル（多対多）か？
  YES --> 専用Repository作成
    例: entity_relation_table
        --> EntityRelationRepository

【質問3】複数テーブルをまたぐ複雑なクエリが頻出か？
  YES --> 専用メソッドを該当Repositoryに追加
    例: EntityRepository.findWithRelations()

【質問4】集計・分析用のクエリか？
  YES --> 専用Repositoryまたは専用メソッド
    例: AnalyticsRepository
        または
        EntityRepository.getStatistics()

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【実装パターン】

最小構成（基本エンティティ数に応じる）
  ├─ CoreEntityRepository
  ├─ SecondaryEntityRepository
  ├─ AuxiliaryEntityRepository
  ├─ EntityTypeRepository
  ├─ EntityRelationRepository
  ├─ EntityAssignmentRepository
  └─ EntityAssociationRepository

拡張検討（必要に応じて）
  ├─ AnalyticsRepository
  │   └─ 複雑な集計・レポート専用
  │
  └─ SearchRepository
      └─ 全文検索・複雑フィルタ専用
```

---

## 設計判断マトリクス 📊

```
┌──────────────────────────────────────────────────────┐
│            設計判断のチェックリスト                  │
└──────────────────────────────────────────────────────┘

Service分割判断
  ├─ [ ] メソッド数が15を超えるか？
  ├─ [ ] 異なるトランザクション境界があるか？
  ├─ [ ] 異なるアクターが使うか？
  ├─ [ ] 独立して進化する可能性があるか？
  └─ [ ] 2つ以上YES --> 分割検討

Repository作成判断
  ├─ [ ] 独立したテーブルか？
  ├─ [ ] 中間テーブル（関連テーブル）か？
  ├─ [ ] 複雑なクエリが3つ以上あるか？
  └─ [ ] 1つ以上YES --> Repository作成

汎用CRUD作成判断
  ├─ [ ] ORMが存在しない環境か？
  ├─ [ ] 生SQLを直接記述しているか？
  ├─ [ ] コード重複が深刻か？
  └─ [ ] 全てNO --> 不要（ORM環境では作らない）

カスタムメソッド作成判断
  ├─ [ ] 3箇所以上で同じクエリを記述するか？
  ├─ [ ] 10行以上の複雑なクエリか？
  ├─ [ ] ビジネス的に意味のある名前を付けられるか？
  └─ [ ] 1つ以上YES --> メソッド作成
```

---

## レイヤー間依存関係の原則 🎯

```
┌──────────────────────────────────────────────────────┐
│              依存の方向性（単方向依存）              │
└──────────────────────────────────────────────────────┘

Component --> Hook --> Service --> Repository --> DB
                         ↓
                       Util
                   (全層から利用可)

【依存ルール】
├─ 下位層は上位層を知らない
├─ 各層は隣接する下位層のみに依存
├─ Util層は例外（全層から利用可能）
└─ 循環依存の禁止

【禁止される依存】
├─ Component --> Repository (Hook経由必須)
├─ Hook --> Repository (Service経由必須)
├─ Repository --> Service (逆方向依存)
└─ Service --> Hook (逆方向依存)


┌──────────────────────────────────────────────────────┐
│               単一責任の原則（SRP）                  │
└──────────────────────────────────────────────────────┘

各層は1つの責務のみ:

Service層
  └─ ビジネスロジックのみ
     └─ データアクセスはRepositoryに委譲

Repository層
  └─ データアクセスのみ
     └─ ビジネスロジックはServiceに委譲

Hook層
  └─ UI状態管理のみ
     └─ ビジネスロジックはServiceに委譲
```

---

## 設計フロー：全体まとめ 🎯

```
┌──────────────────────────────────────────────────────┐
│         既存DB → Service設計の完全フロー             │
└──────────────────────────────────────────────────────┘

PHASE 1: 分析
  ├─ 既存テーブル構造の把握
  ├─ ER図の作成
  └─ ドメイン境界の特定

PHASE 2: ドメインモデリング
  ├─ テーブルを機能ドメインにグルーピング
  ├─ ユースケースの抽出
  └─ Service境界の決定

PHASE 3: Service設計
  ├─ 各Serviceのメソッド一覧作成
  ├─ トランザクション境界の定義
  └─ Service間の依存関係整理

PHASE 4: Repository設計
  ├─ 必要なRepository一覧作成
  ├─ 基本CRUD定義
  ├─ カスタムメソッド設計
  └─ Repository間の関係整理

PHASE 5: 検証
  ├─ 循環依存の確認
  ├─ 責務分離の適切性確認
  └─ テスタビリティの確認

【成果物】
├─ Service一覧表
├─ Repository一覧表
├─ メソッドシグネチャ定義
├─ 依存関係図
└─ データフロー図
```

---

## ファイル構造設計パターン 📁

```
src/
├─ featuer/                      # 機能別フォルダ
│  ├─ [feature-name]/            # 各機能フォルダ
│  │  ├─ services/               # Service層
│  │  │  ├─ coreEntityService.ts
│  │  │  ├─ entityAssociationService.ts
│  │  │  ├─ secondaryEntityService.ts
│  │  │  └─ commonEntityService.ts
│  │  │
│  │  ├─ repositories/           # Repository層
│  │  │  ├─ coreEntityRepository.ts
│  │  │  ├─ secondaryEntityRepository.ts
│  │  │  ├─ entityTypeRepository.ts
│  │  │  ├─ associationRepository.ts
│  │  │  ├─ relationRepository.ts
│  │  │  └─ assignmentRepository.ts
│  │  │
│  │  ├─ hooks/                  # Hook層（フロントエンド）
│  │  │  ├─ useEntityManagement.ts
│  │  │  ├─ useEntityList.ts
│  │  │  └─ useEntityAssociation.ts
│  │  │
│  │  ├─ utils/                  # Util層
│  │  │  ├─ validation.ts
│  │  │  ├─ format.ts
│  │  │  └─ transformation.ts
│  │  │
│  │  ├─ types/                  # 型定義
│  │  │  ├─ entity.types.ts
│  │  │  ├─ association.types.ts
│  │  │  └─ common.types.ts
│  │  │
│  │  ├─ components/             # UIコンポーネント
│  │  ├─ containers/             # コンテナコンポーネント
│  │  ├─ context/                # Context/状態管理
│  │  ├─ core/                   # コアロジック
│  │  └─ docs/                   # ドキュメント
│  │
│  ├─ shared/                    # 共有機能
│  │  ├─ services/               # 共通Service
│  │  ├─ utils/                  # 共通Util
│  │  ├─ types/                  # 共通型定義
│  │  └─ hooks/                  # 共通Hook
│  │
│  └─ ...
│
├─ components/                   # 共通UIコンポーネント
├─ lib/                          # 外部ライブラリ設定
└─ core/                         # コア機能（認証など）
```

---

## 結論：設計原則のまとめ 🎓

```
【設計思考の順序】

1. ドメイン分析
   └─ テーブル --> ドメインへグルーピング

2. ユースケース抽出
   └─ ドメイン --> ユースケース列挙

3. Service境界決定
   └─ ユースケース --> Service分割判断

4. Repository特定
   └─ Service --> 必要なRepository導出

5. 依存関係整理
   └─ Repository間・Service間の関係明確化

【ORM環境での原則】

汎用CRUD層 --> 作らない ❌
  └─ ORMが提供する機能で十分
  └─ 過剰な抽象化を避ける

ドメイン固有メソッド --> 作る ✅
  └─ ビジネス意図を明確に表現
  └─ 複雑性の隠蔽
  └─ 再利用性・保守性の向上
```