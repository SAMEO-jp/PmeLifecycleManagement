## データベース既存時のService層設計思考プロセス 🧠

---

## PHASE 1: ドメイン分析とサービス境界定義 🎯

```
┌──────────────────────────────────────────────────────┐
│        思考の出発点：ドメインから逆算する            │
└──────────────────────────────────────────────────────┘

既存データベース
      ↓
【STEP 1】テーブル群を機能ドメインにグルーピング
      ↓
【STEP 2】各ドメインのユースケースを抽出
      ↓
【STEP 3】ユースケースからService境界を決定
      ↓
【STEP 4】Serviceが必要とするRepositoryを特定
      ↓
【STEP 5】Repository間の依存関係を整理
```

---

## 設計思考フロー：具体例 📋

```md
┌──────────────────────────────────────────────────────┐
│   既存DB：あなたのプロジェクト管理システムの例      │
└──────────────────────────────────────────────────────┘

【既存テーブル構造】
projects
  ├─ id
  ├─ project_name
  ├─ project_number
  └─ created_at

users
  ├─ id
  ├─ email
  └─ name

tasks
  ├─ id
  ├─ task_name
  ├─ task_type_id
  └─ status

task_types
  ├─ id
  └─ type_name

project_members (中間テーブル)
  ├─ project_id
  ├─ user_id
  └─ role

task_user_relations (中間テーブル)
  ├─ task_id
  ├─ user_id
  └─ role_type

task_project_relations (中間テーブル)
  ├─ task_id
  ├─ project_id
  └─ relation_type

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【STEP 1】ドメインへのグルーピング

Domain 1: Project Management
  └─ projects, project_members, task_project_relations

Domain 2: Task Management
  └─ tasks, task_types, task_user_relations

Domain 3: User Management
  └─ users

Domain 4: Member & Assignment Management
  └─ project_members, task_user_relations
```

---

## STEP 2-3: ユースケース抽出とService境界決定 🎭

```
┌──────────────────────────────────────────────────────┐
│        ユースケース → Service マッピング            │
└──────────────────────────────────────────────────────┘

Domain: Project Management
      │
      ├─ UC-01: プロジェクト作成
      ├─ UC-02: プロジェクト一覧取得
      ├─ UC-03: プロジェクト更新
      ├─ UC-04: プロジェクト削除
      ├─ UC-05: メンバー招待
      ├─ UC-06: メンバー削除
      └─ UC-07: ロール変更
      │
      └─→ ProjectService
           └─→ ProjectMemberService (複雑性が高いため分離)

Domain: Task Management
      │
      ├─ UC-11: タスク作成
      ├─ UC-12: タスク割り当て
      ├─ UC-13: タスク完了
      ├─ UC-14: タスク依存関係設定
      └─ UC-15: タスク進捗計算
      │
      └─→ TaskService
           └─→ TaskAssignmentService (割り当てロジック分離)

Domain: User Management
      │
      ├─ UC-21: ユーザー情報取得
      ├─ UC-22: ユーザー更新
      └─ UC-23: ユーザー所属プロジェクト取得
      │
      └─→ UserService

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【Service分割の判断基準】

単一Service ✅
  ├─ 責務が明確
  ├─ 10メソッド以下
  └─ トランザクション境界が一貫

分割すべき ⚠️
  ├─ 15メソッド以上
  ├─ 異なるトランザクション境界
  ├─ 異なるアクター（利用者）
  └─ 独立して変更される可能性

【例】
ProjectService (8メソッド)
  ├─ create()
  ├─ update()
  ├─ delete()
  ├─ findById()
  ├─ findAll()
  ├─ archive()
  ├─ restore()
  └─ getStatistics()

ProjectMemberService (6メソッド) ← 分離
  ├─ inviteMember()
  ├─ removeMember()
  ├─ updateRole()
  ├─ getMembers()
  ├─ acceptInvitation()
  └─ checkMembership()

理由: メンバー管理は独立した複雑なドメインロジック
```

---

## STEP 4: 必要なRepository特定 🔍

```
┌──────────────────────────────────────────────────────┐
│       Service → Repository 依存関係マッピング       │
└──────────────────────────────────────────────────────┘

【思考プロセス】

1. Serviceメソッドを列挙
2. 各メソッドが触るテーブルを特定
3. テーブル単位でRepositoryを定義

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

ProjectService
  │
  ├─ create(data)
  │   └─ 必要: ProjectRepository.create()
  │
  ├─ findById(id)
  │   └─ 必要: ProjectRepository.findById()
  │
  └─ getWithMembers(id)
      ├─ 必要: ProjectRepository.findById()
      └─ 必要: ProjectMemberRepository.findByProjectId()

ProjectMemberService
  │
  ├─ inviteMember(projectId, email, role)
  │   ├─ 必要: ProjectRepository.findById()
  │   ├─ 必要: UserRepository.findByEmail()
  │   ├─ 必要: ProjectMemberRepository
  │   │         .findByProjectAndUser()
  │   └─ 必要: ProjectMemberRepository.create()
  │
  └─ removeMember(projectId, userId)
      ├─ 必要: ProjectMemberRepository
      │         .findByProjectAndUser()
      ├─ 必要: TaskUserRelationRepository.findByUser()
      └─ 必要: ProjectMemberRepository.delete()

TaskService
  │
  ├─ createTask(projectId, data)
  │   ├─ 必要: TaskRepository.create()
  │   ├─ 必要: TaskProjectRelationRepository.create()
  │   └─ 必要: TaskTypeRepository.findById()
  │
  └─ assignTask(taskId, userId)
      ├─ 必要: TaskRepository.findById()
      ├─ 必要: UserRepository.findById()
      └─ 必要: TaskUserRelationRepository.create()

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【必要なRepository一覧】

1対1マッピング（テーブル = Repository）
  ├─ ProjectRepository          ← projects
  ├─ UserRepository              ← users
  ├─ TaskRepository              ← tasks
  └─ TaskTypeRepository          ← task_types

関連テーブル専用Repository
  ├─ ProjectMemberRepository     ← project_members
  ├─ TaskUserRelationRepository  ← task_user_relations
  └─ TaskProjectRelationRepository
                                 ← task_project_relations

【Repository作成の原則】
├─ 1テーブル = 1Repository（基本）
├─ 中間テーブルも独立したRepository
└─ ViewやJOIN結果は既存Repositoryのメソッドで対応
```

---

## STEP 5: Repository設計戦略 🏗️

```
┌──────────────────────────────────────────────────────┐
│          Repository設計：2つのアプローチ             │
└──────────────────────────────────────────────────────┘

アプローチA: 基底Repository + 継承

┌─────────────────────────────────┐
│ BaseRepository<T>               │
│   ├─ findById(id)               │
│   ├─ findAll(options?)          │
│   ├─ create(data)               │
│   ├─ update(id, data)           │
│   ├─ delete(id)                 │
│   └─ count(where?)              │
└───────────┬─────────────────────┘
            │ 継承
    ┌───────┴───────┐
    │               │
ProjectRepository  TaskRepository
    │               │
    ├─ カスタム     ├─ カスタム
    │  メソッド     │  メソッド
    ├─ findByNumber()
    │               ├─ findByStatus()
    └─ findActive() └─ findOverdue()


アプローチB: コンポジション（推奨）

┌─────────────────────────────────┐
│ ProjectRepository               │
│   ├─ 基本CRUD                   │
│   │   ├─ findById()             │
│   │   ├─ findAll()              │
│   │   ├─ create()               │
│   │   └─ update()               │
│   │                             │
│   └─ ドメイン固有クエリ          │
│       ├─ findByNumber()         │
│       ├─ findByOwner()          │
│       ├─ findActive()           │
│       └─ searchByName()         │
└─────────────────────────────────┘

【推奨理由】
├─ Drizzle/Supabaseの型安全性を活かせる
├─ 各Repositoryが完全に独立
├─ テスト・モックが容易
└─ 継承の複雑性を回避
```

---

## 汎用CRUD vs カスタムメソッド設計 ⚖️

```
┌──────────────────────────────────────────────────────┐
│      SQLite時代 vs Supabase+Drizzle時代の違い       │
└──────────────────────────────────────────────────────┘

【SQLite時代】
生SQL記述
  └─ 共通パターンの重複
      └─ 汎用CRUDヘルパー必須

例:
  db.run("INSERT INTO projects ...")
  db.run("INSERT INTO users ...")
  db.run("INSERT INTO tasks ...")
      ↑ 毎回似たようなSQL

解決: 汎用CRUD関数
  ├─ insert(table, data)
  ├─ update(table, id, data)
  └─ delete(table, id)


【Supabase + Drizzle時代】
ORM提供の型安全API
  └─ 既に汎用化されている
      └─ 独自の汎用CRUD不要

例:
  db.insert(projects).values(data)
  db.insert(users).values(data)
  db.insert(tasks).values(data)
      ↑ 既に統一的なインターフェース

結論: Drizzleが提供するAPIをそのまま使う
  └─ 追加の抽象化は不要（過剰設計）

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【Repositoryメソッド設計方針】

基本CRUD（シンプルに実装）
  ├─ findById(id)
  │   └─ return db.select()
  │           .from(projects)
  │           .where(eq(projects.id, id))
  │           .limit(1)
  │
  ├─ findAll(options)
  │   └─ クエリビルダーで柔軟に構築
  │
  ├─ create(data)
  │   └─ return db.insert(projects).values(data)
  │
  └─ update(id, data)
      └─ return db.update(projects)
              .set(data)
              .where(eq(projects.id, id))

ドメイン固有クエリ（価値ある抽象化）
  ├─ findByNumber(number)
  │   └─ ビジネスロジックで頻出
  │
  ├─ findActiveProjects()
  │   └─ 複雑な条件の名前付き
  │
  └─ findWithMembers(id)
      └─ 複雑なJOINの隠蔽

【ガイドライン】
汎用CRUD作らない ✅
  └─ Drizzle APIで十分

ドメイン固有メソッド作る ✅
  └─ 意図を明確に表現
  └─ 複雑性を隠蔽
  └─ 再利用性を提供
```

---

## Repository層の粒度設計 📐

```
┌──────────────────────────────────────────────────────┐
│          Repository粒度の判断フロー                  │
└──────────────────────────────────────────────────────┘

【質問1】このテーブルは独立したエンティティか？
  YES → 専用Repository作成
    例: projects → ProjectRepository

【質問2】このテーブルは中間テーブル（多対多）か？
  YES → 専用Repository作成
    例: project_members → ProjectMemberRepository

【質問3】複数テーブルをまたぐ複雑なクエリが頻出か？
  YES → 専用メソッドを該当Repositoryに追加
    例: ProjectRepository.findWithMembersAndTasks()

【質問4】集計・分析用のクエリか？
  YES → 専用Repositoryまたは専用メソッド
    例: ProjectAnalyticsRepository
        または
        ProjectRepository.getStatistics()

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【実装例】

最小構成（7つのRepository）
  ├─ ProjectRepository
  ├─ UserRepository
  ├─ TaskRepository
  ├─ TaskTypeRepository
  ├─ ProjectMemberRepository
  ├─ TaskUserRelationRepository
  └─ TaskProjectRelationRepository

追加検討（必要に応じて）
  ├─ ProjectAnalyticsRepository
  │   └─ 複雑な集計・レポート専用
  │
  └─ TaskSearchRepository
      └─ 全文検索・複雑フィルタ専用
```

---

## 設計判断マトリクス 📊

```
┌──────────────────────────────────────────────────────┐
│            設計判断のチェックリスト                  │
└──────────────────────────────────────────────────────┘

Service分割判断
  ├─ [ ] メソッド数が15を超えるか？
  ├─ [ ] 異なるトランザクション境界があるか？
  ├─ [ ] 異なるアクターが使うか？
  ├─ [ ] 独立して進化する可能性があるか？
  └─ [ ] 2つ以上YES → 分割検討

Repository作成判断
  ├─ [ ] 独立したテーブルか？
  ├─ [ ] 中間テーブルか？
  ├─ [ ] 複雑なクエリが3つ以上あるか？
  └─ [ ] 1つ以上YES → Repository作成

汎用CRUD作成判断
  ├─ [ ] ORMがない環境か？
  ├─ [ ] 生SQLを直接書いているか？
  ├─ [ ] コード重複が深刻か？
  └─ [ ] 全てNO → 不要（Drizzle使用時）

カスタムメソッド作成判断
  ├─ [ ] 3箇所以上で同じクエリを書くか？
  ├─ [ ] 10行以上の複雑なクエリか？
  ├─ [ ] ビジネス的に意味のある名前を付けられるか？
  └─ [ ] 1つ以上YES → メソッド作成
```

---

## 設計フロー：全体まとめ 🎯

```md
┌──────────────────────────────────────────────────────┐
│         既存DB → Service設計の完全フロー             │
└──────────────────────────────────────────────────────┘

PHASE 1: 分析
  ├─ 既存テーブル構造を理解
  ├─ ER図を描く
  └─ ドメイン境界を特定

PHASE 2: ドメインモデリング
  ├─ テーブルをドメインにグルーピング
  ├─ ユースケースを抽出
  └─ Service境界を決定

PHASE 3: Service設計
  ├─ 各Serviceのメソッド一覧作成
  ├─ トランザクション境界を定義
  └─ Service間の依存関係を整理

PHASE 4: Repository設計
  ├─ 必要なRepository一覧作成
  ├─ 基本CRUD定義
  ├─ カスタムメソッド設計
  └─ Repository間の関係整理

PHASE 5: 検証
  ├─ 循環依存がないか確認
  ├─ 責務分離が適切か確認
  └─ テスタビリティを確認

【成果物】
├─ Service一覧表
├─ Repository一覧表
├─ メソッドシグネチャ定義
├─ 依存関係図
└─ データフロー図
```

---

## 結論 🎓

```
【あなたの質問への答え】

Q1: 設計思考の順序は？
A: ✅ ドメイン分析
   → ユースケース抽出
   → Service境界決定
   → 必要Repository特定

Q2: 汎用CRUDは作る？
A: ❌ Supabase+Drizzle環境では不要
   ✅ Drizzle提供のAPIで十分
   ✅ ドメイン固有メソッドに注力
```